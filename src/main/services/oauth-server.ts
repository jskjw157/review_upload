import { createServer as createHttpsServer, ServerOptions } from 'node:https';
import { ServerResponse } from 'node:http';
import { URL } from 'node:url';
import crypto from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import { app } from 'electron';

/**
 * State token stored during OAuth flow for CSRF protection
 */
interface OAuthState {
  /** Random state string sent to Cafe24 */
  state: string;
  /** Timestamp when state was created (for expiration check) */
  createdAt: number;
  /** Original OAuth config used to initiate the flow */
  config: {
    mallId: string;
    clientId: string;
  };
}

/**
 * Result from the callback server after receiving authorization code
 */
export interface CallbackResult {
  /** Whether the callback was successful */
  success: boolean;
  /** Authorization code received from Cafe24 (if success=true) */
  code?: string;
  /** Error message if callback failed */
  error?: string;
  /** Error description from Cafe24 API */
  errorDescription?: string;
}

// In-memory storage for the current OAuth state
// Only one OAuth flow should be active at a time
let currentState: OAuthState | null = null;

/**
 * Gets the path to SSL certificates.
 * In development: project root /certs/
 * In production: app resources directory
 */
function getCertPaths(): { key: string; cert: string } {
  const isDev = process.env.NODE_ENV === 'development';

  if (isDev) {
    // Development: use certs from project root
    const certsDir = path.join(process.cwd(), 'certs');
    return {
      key: path.join(certsDir, 'localhost.key'),
      cert: path.join(certsDir, 'localhost.crt'),
    };
  } else {
    // Production: use certs from app resources
    const resourcesPath = process.resourcesPath || app.getAppPath();
    return {
      key: path.join(resourcesPath, 'certs', 'localhost.key'),
      cert: path.join(resourcesPath, 'certs', 'localhost.crt'),
    };
  }
}

/**
 * Generates a cryptographically secure random state parameter for CSRF protection.
 *
 * This state parameter is sent to Cafe24's authorization endpoint and must be
 * verified when the callback is received to prevent CSRF attacks.
 *
 * @returns A random hex string (32 bytes = 64 characters)
 *
 * @example
 * const state = generateState();
 * // Returns: "a1b2c3d4e5f6..."
 */
export function generateState(): string {
  return crypto.randomBytes(32).toString('hex');
}

/**
 * Stores the OAuth state for later validation during callback.
 *
 * This function saves the state parameter along with metadata so we can
 * verify the callback is legitimate and not a CSRF attack.
 *
 * @param state - The state string generated by generateState()
 * @param config - OAuth configuration containing mallId and clientId
 */
export function storeState(state: string, config: { mallId: string; clientId: string }): void {
  currentState = {
    state,
    createdAt: Date.now(),
    config,
  };
  console.log('[oauth] State generated and stored:', state.substring(0, 8) + '...');
}

/**
 * Validates that the received state matches the stored state.
 *
 * Critical security function - prevents CSRF attacks by ensuring the callback
 * is from the same flow we initiated.
 *
 * EDGE CASES HANDLED:
 * - Missing state parameter (possible CSRF attack)
 * - No stored state (server restart during OAuth flow)
 * - State mismatch (possible CSRF or replay attack)
 * - State expiration (user took too long to authorize)
 * - Timing attacks (constant-time comparison)
 *
 * @param receivedState - State parameter from callback URL
 * @returns True if state is valid and not expired, false otherwise
 */
export function validateState(receivedState: string | undefined): boolean {
  // Edge Case 1: No state parameter received
  // This could indicate a CSRF attack or malformed callback
  if (!receivedState) {
    console.warn('[oauth] Callback validation failed: no state parameter received');
    console.warn('[oauth] This may indicate a CSRF attack or malformed callback URL');
    return false;
  }

  // Edge Case 2: No stored state found
  // This happens if:
  // - App was restarted during OAuth flow
  // - Multiple OAuth flows attempted simultaneously
  // - State was already used (one-time token)
  if (!currentState) {
    console.warn('[oauth] Callback validation failed: no stored state found');
    console.warn('[oauth] Possible causes: app restart, multiple flows, or already used state');
    return false;
  }

  // Edge Case 3: State length mismatch
  // timingSafeEqual requires equal-length buffers
  // If lengths differ, it's definitely invalid (and would throw error)
  if (receivedState.length !== currentState.state.length) {
    console.warn('[oauth] Callback validation failed: state length mismatch');
    console.warn('[oauth] Expected length:', currentState.state.length, 'Received:', receivedState.length);
    currentState = null;
    return false;
  }

  // Edge Case 4: State content mismatch (constant-time comparison)
  // Using timingSafeEqual prevents timing attacks where attacker
  // could measure response time to guess state value
  let isStateValid = false;
  try {
    isStateValid = crypto.timingSafeEqual(
      Buffer.from(receivedState),
      Buffer.from(currentState.state)
    );
  } catch (error) {
    // This shouldn't happen after length check, but be defensive
    console.error('[oauth] Error during state comparison:', error);
    currentState = null;
    return false;
  }

  if (!isStateValid) {
    console.warn('[oauth] Callback validation failed: state mismatch');
    console.warn('[oauth] This may indicate a CSRF attack or replay attack');
    currentState = null;
    return false;
  }

  // Edge Case 5: State expiration (10 minutes)
  // Prevents replay attacks with old authorization codes
  const expirationTime = 10 * 60 * 1000;
  const age = Date.now() - currentState.createdAt;
  if (age > expirationTime) {
    console.warn('[oauth] Callback validation failed: state expired');
    console.warn('[oauth] State age:', Math.floor(age / 1000), 'seconds (max: 600 seconds)');
    console.warn('[oauth] User took too long to authorize. Please try again.');
    currentState = null;
    return false;
  }

  // State is valid - clear it (one-time use)
  console.log('[oauth] State validation successful');
  console.log('[oauth] State age:', Math.floor(age / 1000), 'seconds');
  currentState = null;
  return true;
}

/**
 * Builds the Cafe24 OAuth authorization URL with all required parameters.
 *
 * This URL will be opened in the user's browser to initiate the OAuth flow.
 * The user will log in to Cafe24 and approve permissions.
 *
 * @param config - OAuth configuration
 * @param state - CSRF protection state parameter
 * @param scope - Space-separated list of permission scopes
 * @returns Complete authorization URL to open in browser
 */
export function buildAuthorizationUrl(
  config: { mallId: string; clientId: string; redirectUri: string },
  state: string,
  scope?: string
): string {
  const baseUrl = `https://${config.mallId}.cafe24api.com/api/v2/oauth/authorize`;
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: config.clientId,
    state,
    redirect_uri: config.redirectUri,
  });

  if (scope) {
    params.append('scope', scope);
  }

  const url = `${baseUrl}?${params.toString()}`;
  console.log('[oauth] Authorization URL built:', url.substring(0, 80) + '...');
  return url;
}

/**
 * Creates and starts a local HTTPS server to receive the OAuth callback.
 *
 * This server listens on the port specified in redirectUri (e.g., localhost:3000)
 * and waits for Cafe24 to redirect back with the authorization code.
 *
 * Uses self-signed certificates for local development.
 *
 * @param port - Port number to listen on (e.g., 3000)
 * @param redirectPath - URL path to expect (e.g., '/oauth/callback')
 * @returns Promise resolving to CallbackResult when code is received or error occurs
 */
export function startCallbackServer(port: number, redirectPath: string): Promise<CallbackResult> {
  return new Promise((resolve) => {
    // Load SSL certificates
    const certPaths = getCertPaths();
    let sslOptions: ServerOptions;

    try {
      sslOptions = {
        key: fs.readFileSync(certPaths.key),
        cert: fs.readFileSync(certPaths.cert),
      };
      console.log('[oauth] SSL certificates loaded successfully');
    } catch (error) {
      console.error('[oauth] Failed to load SSL certificates:', error);
      resolve({
        success: false,
        error: 'ssl_error',
        errorDescription: 'SSL 인증서를 로드할 수 없습니다. certs/ 폴더에 인증서가 있는지 확인하세요.',
      });
      return;
    }

    // Timeout after 5 minutes
    const timeoutHandle = setTimeout(() => {
      console.warn('[oauth] Callback server timeout after 5 minutes');
      server.close();
      resolve({
        success: false,
        error: 'timeout',
        errorDescription: 'Authorization request timed out. Please try again.',
      });
    }, 5 * 60 * 1000);

    const server = createHttpsServer(sslOptions, (req, res) => {
      const url = new URL(req.url || '', `https://localhost:${port}`);

      // Only handle the expected redirect path
      if (url.pathname !== redirectPath) {
        console.log('[oauth] Received request on unexpected path:', url.pathname);
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('Not Found');
        return;
      }

      // Parse query parameters
      const params = parseQueryParams(url.search);
      const { code, state, error, error_description } = params;

      console.log('[oauth] Callback received on', redirectPath);

      // Check if there's an error from Cafe24
      if (error) {
        console.error('[oauth] Cafe24 returned error:', error, error_description);
        sendCallbackResponse(
          res,
          false,
          `Authorization failed: ${error_description || error}`
        );
        clearTimeout(timeoutHandle);
        server.close();
        resolve({
          success: false,
          error,
          errorDescription: error_description,
        });
        return;
      }

      // Validate that code is present
      if (!code) {
        console.error('[oauth] No authorization code in callback');
        sendCallbackResponse(res, false, 'No authorization code received. Please try again.');
        clearTimeout(timeoutHandle);
        server.close();
        resolve({
          success: false,
          error: 'no_code',
          errorDescription: 'Authorization code not found in callback',
        });
        return;
      }

      // Validate state parameter (critical for CSRF protection)
      if (!validateState(state)) {
        console.error('[oauth] State validation failed');
        sendCallbackResponse(res, false, 'Security validation failed. Please try again.');
        clearTimeout(timeoutHandle);
        server.close();
        resolve({
          success: false,
          error: 'invalid_state',
          errorDescription: 'State parameter validation failed',
        });
        return;
      }

      // Success - send response to browser and resolve
      console.log('[oauth] Authorization successful. Code:', code.substring(0, 10) + '...');
      sendCallbackResponse(res, true, 'Authentication successful! You can close this window.');
      clearTimeout(timeoutHandle);
      server.close();
      resolve({
        success: true,
        code,
      });
    });

    server.listen(port, 'localhost', () => {
      console.log('[oauth] HTTPS Callback server started on https://localhost:' + port + redirectPath);
    });

    server.on('error', (error) => {
      console.error('[oauth] Callback server error:', error);
      clearTimeout(timeoutHandle);

      // Edge Case: Port already in use
      // This happens when:
      // - Another app is using port 3000
      // - Previous OAuth flow didn't clean up properly
      // - Multiple OAuth flows started simultaneously
      const errorCode = (error as NodeJS.ErrnoException).code;

      let errorMessage = 'Failed to start callback server';
      if (errorCode === 'EADDRINUSE') {
        errorMessage = `Port ${port} is already in use. Please close other applications using this port or choose a different port in your redirect URI.`;
        console.error('[oauth] Port conflict detected. Suggested actions:');
        console.error('[oauth] 1. Check for other apps on port', port);
        console.error('[oauth] 2. Try a different port in redirect URI');
        console.error('[oauth] 3. Wait a moment and try again');
      } else if (errorCode === 'EACCES') {
        // Edge Case: Permission denied (usually ports < 1024)
        errorMessage = `Permission denied to bind port ${port}. Try using a port >= 1024.`;
        console.error('[oauth] Permission error. System ports (< 1024) require admin privileges.');
      } else if (errorCode === 'EADDRNOTAVAIL') {
        // Edge Case: Address not available
        errorMessage = 'localhost is not available. Check network configuration.';
        console.error('[oauth] Cannot bind to localhost. Network configuration issue.');
      }

      resolve({
        success: false,
        error: 'server_error',
        errorDescription: errorMessage,
      });
    });
  });
}

/**
 * Sends an HTML response to the user's browser after callback.
 *
 * This function generates a user-friendly page showing success or error message.
 *
 * @param res - HTTP response object
 * @param success - Whether the callback was successful
 * @param message - Message to display to user
 */
function sendCallbackResponse(res: ServerResponse, success: boolean, message: string): void {
  const statusCode = success ? 200 : 400;
  const bgColor = success ? '#f0fdf4' : '#fef2f2';
  const titleColor = success ? '#16a34a' : '#dc2626';
  const title = success ? '✓ 성공' : '✗ 오류';

  const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>카페24 인증</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: ${bgColor};
    }
    .container {
      text-align: center;
      padding: 2rem;
      max-width: 500px;
    }
    h1 {
      color: ${titleColor};
      font-size: 2rem;
      margin-bottom: 1rem;
    }
    p {
      color: #333;
      font-size: 1rem;
      line-height: 1.5;
      margin-bottom: 0.5rem;
    }
    .small {
      color: #666;
      font-size: 0.875rem;
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>${title}</h1>
    <p>${message}</p>
    <p class="small">이 창을 닫아도 됩니다.</p>
  </div>
  <script>
    // 자동 닫기 (3초 후)
    setTimeout(() => {
      window.close();
    }, 3000);
  </script>
</body>
</html>`;

  res.writeHead(statusCode, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end(html);
}

/**
 * Parses query parameters from a URL search string.
 *
 * Helper function to extract query parameters from request URL.
 *
 * @param searchString - Search string from URL (e.g., "?code=abc&state=xyz")
 * @returns Object containing query parameters
 */
function parseQueryParams(searchString: string): Record<string, string> {
  const params = new URLSearchParams(searchString);
  const result: Record<string, string> = {};

  params.forEach((value, key) => {
    result[key] = value;
  });

  return result;
}
