---
alwaysApply: true
---

---

description: Minimizes tool calls and maximizes AI agent efficiency
globs: ["**/*"]
alwaysApply: true

---

# Efficiency Optimization Rules

## ğŸ¯ Core Principle: Every Tool Call Counts

### Tool Call Hierarchy

```
1. NO CALL > Think first, can you answer without tools?
2. ONE CALL > Batch operations into single calls
3. FEW CALLS > Strategic sequence when necessary
4. MANY CALLS > Only for complex research tasks
```

## ğŸ“Š Efficiency Metrics

### Track Your Performance

```
EFFICIENCY_SCORE:
- 0 tool calls for knowledge-based answers = 100%
- 1 tool call for simple lookups = 90%
- 2-3 calls for standard tasks = 80%
- 4-5 calls for complex tasks = 70%
- 6+ calls = Review if necessary
```

## ğŸš€ Zero-Call Strategies

### Answer Directly When Possible

```javascript
// USER: "How do I create a React component?"
// âŒ BAD: Search for React component syntax
// âœ… GOOD: Provide answer from knowledge

// USER: "What's the syntax for Python list comprehension?"
// âŒ BAD: Search Python documentation
// âœ… GOOD: Show syntax directly with examples
```

### Knowledge-First Approach

```
Before ANY tool call, ask:
1. Do I already know this?
2. Is this stable information?
3. Can I provide value without searching?

If YES to all â†’ Answer directly
```

## ğŸ’¡ Single-Call Patterns

### File Operations

```bash
# âŒ BAD: Multiple calls
cat package.json
ls src/
grep -r "TODO" .

# âœ… GOOD: Single call
cat package.json && echo "---" && ls -la src/ && echo "---" && grep -r "TODO" . | head -20
```

### Code Analysis

```javascript
// âŒ BAD: Separate reads
// Read file1.js
// Read file2.js
// Read file3.js

// âœ… GOOD: Batch read
const files = ['file1.js', 'file2.js', 'file3.js']
const contents = await Promise.all(files.map((f) => fs.readFile(f, 'utf8')))
```

### Information Gathering

```bash
# âŒ BAD: Sequential discovery
pwd
git status
git branch
npm list

# âœ… GOOD: Combined context
echo "=== Project Status ===" && \
pwd && \
git status -sb && \
git branch --show-current && \
npm list --depth=0 2>/dev/null | grep -E "^(â”œ|â””)" | head -10
```

## ğŸª Batching Strategies

### File Creation

```bash
# âŒ BAD: Individual creates
touch src/index.js
touch src/utils.js
touch src/config.js

# âœ… GOOD: Batch creation
mkdir -p src && touch src/{index,utils,config}.js
```

### Multi-File Updates

```javascript
// âŒ BAD: Update files one by one
updateFile('config.js', configContent)
updateFile('index.js', indexContent)
updateFile('utils.js', utilsContent)

// âœ… GOOD: Batch update
const updates = [
    { file: 'config.js', content: configContent },
    { file: 'index.js', content: indexContent },
    { file: 'utils.js', content: utilsContent },
]
await Promise.all(updates.map((u) => fs.writeFile(u.file, u.content)))
```

## ğŸ”„ Smart Caching

### Remember Previous Results

```javascript
// Store expensive computations
CACHED_RESULTS = {
    projectStructure: null,
    dependencies: null,
    configuration: null,
}

// Use cache when available
if (!CACHED_RESULTS.projectStructure) {
    CACHED_RESULTS.projectStructure = await analyzeProject()
}
return CACHED_RESULTS.projectStructure
```

### Context Preservation

```
PRESERVE_BETWEEN_CALLS:
- File contents already read
- Command outputs already seen
- Discovered patterns
- Validated information
```

## ğŸ“‰ Tool Call Reduction Patterns

### Search Optimization

```
# âŒ BAD: Multiple searches
search: "React hooks"
search: "React useState"
search: "React useEffect"

# âœ… GOOD: Comprehensive search
search: "React hooks useState useEffect patterns"
```

### Progressive Enhancement

```javascript
// Start simple, enhance only if needed
// Level 1: Try with existing knowledge
// Level 2: Single targeted search
// Level 3: Deep dive only if critical
```

## âš¡ Performance Patterns

### Lazy Loading

```javascript
// âŒ BAD: Load everything upfront
const allFiles = await loadAllProjectFiles()

// âœ… GOOD: Load only what's needed
const getFile = async (path) => {
    if (!cache[path]) {
        cache[path] = await loadFile(path)
    }
    return cache[path]
}
```

### Early Termination

```bash
# âŒ BAD: Process everything
find . -name "*.js" | xargs grep "pattern"

# âœ… GOOD: Stop when found
find . -name "*.js" -exec grep -l "pattern" {} \; | head -1
```

## ğŸ¯ Decision Trees

### Should I Use a Tool?

```
Is it a fact question?
â”œâ”€ YES â†’ Is it current/changing info?
â”‚   â”œâ”€ YES â†’ Use tool (1 call)
â”‚   â””â”€ NO â†’ Answer from knowledge
â””â”€ NO â†’ Is it a task?
    â”œâ”€ YES â†’ Can I batch operations?
    â”‚   â”œâ”€ YES â†’ Single batched call
    â”‚   â””â”€ NO â†’ Minimize calls
    â””â”€ NO â†’ Provide guidance
```

### Tool Selection

```
Need information?
â”œâ”€ Web search â†’ Current events, prices, news
â”œâ”€ Read file â†’ Specific file content
â”œâ”€ Terminal â†’ System state, file operations
â””â”€ Analysis â†’ Complex calculations only
```

## ğŸ“Š Efficiency Anti-Patterns

### Avoid These

```
âŒ Searching for basic syntax
âŒ Multiple calls for related info
âŒ Reading files already in context
âŒ Unnecessary state checks
âŒ Redundant validations
âŒ Over-verification
```

### Embrace These

```
âœ… Batch related operations
âœ… Cache expensive results
âœ… Use knowledge first
âœ… Combine commands
âœ… Trust previous results
âœ… Fail fast
```

## ğŸ’¾ Resource Conservation

### API Token Optimization

```javascript
// âŒ BAD: Wasteful
for (const item of items) {
    await processItem(item) // API call each
}

// âœ… GOOD: Efficient
const batchSize = 100
for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize)
    await processBatch(batch) // Single API call
}
```

### Memory Efficiency

```javascript
// âŒ BAD: Load entire file
const fullContent = await fs.readFile('large.csv')
const lines = fullContent.split('\n')

// âœ… GOOD: Stream processing
const stream = fs.createReadStream('large.csv')
const rl = readline.createInterface({ input: stream })
for await (const line of rl) {
    // Process line by line
}
```

## ğŸƒ Speed Optimizations

### Parallel vs Sequential

```javascript
// âŒ BAD: Sequential (slow)
const a = await fetchA()
const b = await fetchB()
const c = await fetchC()

// âœ… GOOD: Parallel (fast)
const [a, b, c] = await Promise.all([fetchA(), fetchB(), fetchC()])
```

### Short-Circuit Evaluation

```javascript
// Stop as soon as condition met
const result = await findFirst(items, async (item) => {
    return await checkCondition(item)
})
```

## ğŸ“ˆ Efficiency Report Card

### Rate Your Session

```
EXCELLENT (A+): 0-1 tool calls
- Answered from knowledge
- Batched if needed

GOOD (B): 2-3 tool calls
- Minimal exploration
- Efficient execution

NEEDS WORK (C): 4-5 tool calls
- Some redundancy
- Could batch better

INEFFICIENT (D): 6+ tool calls
- Excessive searching
- Poor batching
```

Remember: The best tool call is the one you don't make!
