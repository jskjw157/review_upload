---
description: ì™¸ë¶€ API ì—°ë™ ê°€ì´ë“œ - HTTP í´ë¼ì´ì–¸íŠ¸, ì—ëŸ¬ ì²˜ë¦¬, ì¬ì‹œë„ ë¡œì§
globs: ["src/main/services/**/*.ts", "src/renderer/services/**/*.ts"]
alwaysApply: false
---

# API ì—°ë™ ê°€ì´ë“œ

## ğŸŒ HTTP í´ë¼ì´ì–¸íŠ¸ íŒ¨í„´

### ê¸°ë³¸ HTTP í´ë¼ì´ì–¸íŠ¸ êµ¬ì¡°
```typescript
interface HttpClientConfig {
  baseUrl: string;
  timeout?: number;
  defaultHeaders?: Record<string, string>;
}

interface RequestOptions {
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  path: string;
  headers?: Record<string, string>;
  body?: unknown;
  params?: Record<string, string>;
}

interface ApiResponse<T> {
  data: T;
  status: number;
  headers: Headers;
}

class HttpClient {
  constructor(private config: HttpClientConfig) {}
  
  async request<T>(options: RequestOptions): Promise<ApiResponse<T>> {
    const url = this.buildUrl(options.path, options.params);
    const headers = {
      ...this.config.defaultHeaders,
      ...options.headers,
    };
    
    const response = await fetch(url, {
      method: options.method,
      headers,
      body: options.body ? JSON.stringify(options.body) : undefined,
    });
    
    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }
    
    return {
      data: await response.json(),
      status: response.status,
      headers: response.headers,
    };
  }
  
  // í¸ì˜ ë©”ì„œë“œ
  get<T>(path: string, params?: Record<string, string>) {
    return this.request<T>({ method: 'GET', path, params });
  }
  
  post<T>(path: string, body: unknown) {
    return this.request<T>({ method: 'POST', path, body });
  }
}
```

## âš ï¸ ì—ëŸ¬ ì²˜ë¦¬

### API ì—ëŸ¬ í´ë˜ìŠ¤ ê³„ì¸µ
```typescript
// ê¸°ë³¸ API ì—ëŸ¬
export class ApiError extends Error {
  constructor(
    public status: number,
    public message: string,
    public code?: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
  
  static isApiError(error: unknown): error is ApiError {
    return error instanceof ApiError;
  }
}

// ì¸ì¦ ê´€ë ¨ ì—ëŸ¬
export class AuthError extends ApiError {
  constructor(message: string, details?: unknown) {
    super(401, message, 'AUTH_ERROR', details);
    this.name = 'AuthError';
  }
}

// í† í° ë§Œë£Œ ì—ëŸ¬
export class TokenExpiredError extends AuthError {
  constructor() {
    super('Access token has expired');
    this.name = 'TokenExpiredError';
  }
}

// ìš”ì²­ ì œí•œ ì—ëŸ¬
export class RateLimitError extends ApiError {
  constructor(
    public retryAfter: number,
    details?: unknown
  ) {
    super(429, `Rate limited. Retry after ${retryAfter}s`, 'RATE_LIMIT', details);
    this.name = 'RateLimitError';
  }
}
```

### ì—ëŸ¬ í•¸ë“¤ë§ íŒ¨í„´
```typescript
async function callApi<T>(
  request: () => Promise<T>,
  onTokenExpired?: () => Promise<void>
): Promise<T> {
  try {
    return await request();
  } catch (error) {
    // í† í° ë§Œë£Œ ì‹œ ìë™ ê°±ì‹  í›„ ì¬ì‹œë„
    if (error instanceof TokenExpiredError && onTokenExpired) {
      await onTokenExpired();
      return await request();
    }
    
    // Rate Limit ì²˜ë¦¬
    if (error instanceof RateLimitError) {
      await delay(error.retryAfter * 1000);
      return await request();
    }
    
    throw error;
  }
}
```

## ğŸ”„ ì¬ì‹œë„ ë¡œì§

### ì§€ìˆ˜ ë°±ì˜¤í”„ (Exponential Backoff)
```typescript
interface RetryConfig {
  maxRetries: number;
  baseDelay: number;      // ms
  maxDelay: number;       // ms
  shouldRetry: (error: unknown) => boolean;
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 10000,
  shouldRetry: (error) => {
    if (error instanceof ApiError) {
      // 5xx ì—ëŸ¬ì™€ ì¼ë¶€ 4xx ì—ëŸ¬ë§Œ ì¬ì‹œë„
      return error.status >= 500 || error.status === 429;
    }
    // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì¬ì‹œë„
    return error instanceof TypeError;
  },
};

async function withRetry<T>(
  fn: () => Promise<T>,
  config: Partial<RetryConfig> = {}
): Promise<T> {
  const { maxRetries, baseDelay, maxDelay, shouldRetry } = {
    ...DEFAULT_RETRY_CONFIG,
    ...config,
  };
  
  let lastError: unknown;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (attempt === maxRetries || !shouldRetry(error)) {
        throw error;
      }
      
      // ì§€ìˆ˜ ë°±ì˜¤í”„ + ì§€í„°(jitter)
      const delay = Math.min(
        baseDelay * Math.pow(2, attempt) + Math.random() * 1000,
        maxDelay
      );
      
      console.log(`Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}
```

## ğŸ“Š ìš”ì²­ ëŒ€ê¸°ì—´ (Rate Limiting)

### ìš”ì²­ ì œí•œ ê´€ë¦¬
```typescript
class RequestQueue {
  private queue: Array<() => Promise<void>> = [];
  private isProcessing = false;
  private lastRequestTime = 0;
  
  constructor(
    private minInterval: number = 100 // ms between requests
  ) {}
  
  async enqueue<T>(request: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await request();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.processQueue();
    });
  }
  
  private async processQueue() {
    if (this.isProcessing || this.queue.length === 0) return;
    
    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const elapsed = Date.now() - this.lastRequestTime;
      const waitTime = Math.max(0, this.minInterval - elapsed);
      
      if (waitTime > 0) {
        await delay(waitTime);
      }
      
      const task = this.queue.shift();
      if (task) {
        this.lastRequestTime = Date.now();
        await task();
      }
    }
    
    this.isProcessing = false;
  }
}
```

## ğŸ” ì¸ì¦ í† í° ê´€ë¦¬

### ìë™ í† í° ê°±ì‹  ë˜í¼
```typescript
interface TokenManager {
  getAccessToken(): Promise<string>;
  refreshAccessToken(): Promise<string>;
  isTokenExpired(): boolean;
}

function createAuthenticatedClient(
  baseClient: HttpClient,
  tokenManager: TokenManager
): HttpClient {
  return {
    async request<T>(options: RequestOptions): Promise<ApiResponse<T>> {
      // í† í° ë§Œë£Œ ì„ë°• ì‹œ ë¯¸ë¦¬ ê°±ì‹ 
      if (tokenManager.isTokenExpired()) {
        await tokenManager.refreshAccessToken();
      }
      
      const token = await tokenManager.getAccessToken();
      const authOptions = {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${token}`,
        },
      };
      
      try {
        return await baseClient.request<T>(authOptions);
      } catch (error) {
        // 401 ì—ëŸ¬ ì‹œ í† í° ê°±ì‹  í›„ ì¬ì‹œë„
        if (error instanceof ApiError && error.status === 401) {
          const newToken = await tokenManager.refreshAccessToken();
          authOptions.headers.Authorization = `Bearer ${newToken}`;
          return await baseClient.request<T>(authOptions);
        }
        throw error;
      }
    },
  };
}
```

## ğŸ“¦ ì‘ë‹µ ìºì‹±

### ê°„ë‹¨í•œ ìºì‹œ êµ¬í˜„
```typescript
interface CacheEntry<T> {
  data: T;
  expiresAt: number;
}

class ResponseCache {
  private cache = new Map<string, CacheEntry<unknown>>();
  
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    return entry.data as T;
  }
  
  set<T>(key: string, data: T, ttlMs: number): void {
    this.cache.set(key, {
      data,
      expiresAt: Date.now() + ttlMs,
    });
  }
  
  invalidate(keyPattern?: RegExp): void {
    if (!keyPattern) {
      this.cache.clear();
      return;
    }
    
    for (const key of this.cache.keys()) {
      if (keyPattern.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

// ìºì‹± ë˜í¼
async function cachedRequest<T>(
  cache: ResponseCache,
  cacheKey: string,
  ttlMs: number,
  request: () => Promise<T>
): Promise<T> {
  const cached = cache.get<T>(cacheKey);
  if (cached) return cached;
  
  const data = await request();
  cache.set(cacheKey, data, ttlMs);
  return data;
}
```

## ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜

```typescript
// ë”œë ˆì´
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// URL ë¹Œë“œ
function buildUrl(base: string, path: string, params?: Record<string, string>): string {
  const url = new URL(path, base);
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });
  }
  return url.toString();
}

// ì‘ë‹µ ìœ íš¨ì„± ê²€ì‚¬
function assertResponse<T>(
  response: unknown,
  validator: (data: unknown) => data is T
): asserts response is T {
  if (!validator(response)) {
    throw new ApiError(500, 'Invalid response format');
  }
}
```
