---
alwaysApply: true
---

---

description: Intelligent context management and memory optimization strategies
globs: ["**/*"]
alwaysApply: false

---

# Memory Management & Context Optimization

## ğŸ§  Context Priority Levels

### Level 1: CRITICAL (Always Retain)

```
- Current task definition
- Active file being edited
- Recent error messages
- Explicit user requirements
- Security/authentication context
```

### Level 2: IMPORTANT (Retain if Relevant)

```
- Related file imports/exports
- Function signatures being used
- Recent code modifications
- Database schema if querying
- API contracts if integrating
```

### Level 3: HELPFUL (Include if Space)

```
- Project conventions discovered
- Similar patterns in codebase
- Previous solutions to similar problems
- Performance considerations
```

### Level 4: ARCHIVE (Prune First)

```
- Successful operations from >10 messages ago
- Resolved errors
- Exploratory dead ends
- Duplicate information
```

## ğŸ“Š Context Pruning Strategy

### When Context Gets Full:

```
1. Remove Level 4 items first
2. Summarize Level 3 items
3. Compress Level 2 (keep signatures only)
4. NEVER remove Level 1
```

### Smart Compression Examples:

```javascript
// BEFORE: Full context
"User implemented a UserController with methods:
- getUsers(): returns all users with pagination
- getUser(id): returns single user by ID
- createUser(data): creates new user with validation
- updateUser(id, data): updates existing user
- deleteUser(id): soft deletes user"

// AFTER: Compressed
"UserController implemented with CRUD operations (get/create/update/delete)"
```

## ğŸ¯ Focus Maintenance

### Track Current Objective

```
CURRENT_TASK: [Implementation of user authentication]
SUBTASK: [Adding JWT validation middleware]
BLOCKED_BY: [Need database schema]
NEXT_STEP: [Test the middleware]
```

### Context Switching

```
When switching tasks:
1. Summarize completed work
2. Clear Level 3-4 context
3. Load new task context
4. Preserve learned patterns
```

## ğŸ’¡ Pattern Recognition & Storage

### Store Reusable Patterns

```javascript
// PATTERN DETECTED: Error handling in this project
try {
    // operation
} catch (error) {
    logger.error(`${context}: ${error.message}`, { error, metadata })
    throw new CustomError(error.message, ERROR_CODES.OPERATION_FAILED)
}
// STORE: Project uses custom error wrapper with logging
```

### Project Conventions

```
DISCOVERED PATTERNS:
- File naming: kebab-case.ts
- Exports: Named exports preferred
- Testing: *.test.ts files
- API routes: /api/v1/resource
```

## ğŸ” Information Retrieval

### Quick Reference Format

```
FILE_STRUCTURE:
src/
  controllers/ (business logic)
  services/ (external integrations)
  utils/ (shared helpers)
  types/ (TypeScript interfaces)

KEY_FUNCTIONS:
- authenticate() in auth.service.ts
- validateRequest() in middleware/
- handleError() in utils/error.ts
```

### Relationship Mapping

```
UserController -> UserService -> UserRepository
     |                |               |
     v                v               v
validation.ts    external-api.ts   database.ts
```

## ğŸ“ˆ Context Quality Metrics

### Good Context Indicators:

-   Can answer "what was I doing?" instantly
-   Know which files are affected
-   Understand dependencies
-   Remember key decisions

### Bad Context Indicators:

-   Repeating same questions
-   Lost track of requirements
-   Forgetting recent changes
-   Circular discussions

## ğŸš€ Optimization Techniques

### Batch Related Information

```
// Instead of scattered context:
"User model has email field"
"User model has password field"
"User model has createdAt field"

// Batch together:
"User model: { email, password, createdAt, updatedAt, role }"
```

### Use References

```
// Instead of repeating:
"The validateEmail function checks format and domain"
"The validateEmail function returns boolean"

// Reference once:
validateEmail(): boolean - checks format and domain
// Then refer as: "use validateEmail() defined above"
```

## ğŸ’¾ Session Continuity

### End of Session Summary

```
SESSION SUMMARY:
- Implemented: User authentication with JWT
- Modified: auth.service.ts, user.controller.ts
- Decisions: Used refresh tokens, 7-day expiry
- TODO: Add rate limiting, implement logout
- Gotchas: Remember to handle token refresh edge case
```

### Session Startup

```
RESUMING FROM:
- Working on: [Feature name]
- Last action: [What was completed]
- Next step: [What needs doing]
- Context: @previous-session-summary
```

## ğŸª Memory Management Commands

### Mental Commands to Use:

```
COMPRESS: Summarize current context
PRUNE: Remove outdated information
FOCUS: Narrow to current task only
SNAPSHOT: Save current state
RESTORE: Load previous context
```

### Context Health Check:

```
Every 10 interactions:
1. Is context still relevant?
2. Any duplicate information?
3. Missing critical context?
4. Can I answer user's original request?
```

Remember: Quality > Quantity. Better to have 5 relevant facts than 50 irrelevant ones.
